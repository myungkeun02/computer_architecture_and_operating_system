# 페이징을 통한 가상 메모리 관리
가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리
크기보다 큰 프로세스를 실행할 수 있게 하는 기술이다.
이를 가능케 하는 가상 메모리 관리 기법에는 크게 페이징과 세그멘테이션이 있지만
현대 대부분의 운영체제가 사용하는 방식은 페이징 기법이다.

### 1. 페이징이란?
    페이징은 프로세스의 논리 주소 공간을 페이지 라는 일정한 단위로 자르고,
    메모리 물리 주소 공간을 프레임 이라는 페이지와 동일한 크기의 일정한 단위로
    자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.

    페이징을 사용하는 시스템에서는 프로세스 전체가 스왑인/아웃 되는것이 아닌
    페이지 단위로 스왑 인/아웃되는데 이를 페이지 인, 페이지 아웃 이라고 한다.

    이는 다르게 말하면 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에
    적재될 필요가 없다는 의미로 이를 통해 물리 메모리보다 큰 프로세스를 실행할 수 있다.
    
### 1. 페이지 테이블
    페이징 기법을 사용하면 프로세스가 메모리에 불연속적으로 배치되면서 CPU가
    다음에 실행할 명령어 위치를 찾기가 어려워진다.
    이를 극복하기 위해 페이징 시스템은 프로세스가 비록 물리주소에 불연속적으로
    배치되더라도 논리 주소에는 연속적으로 배치되도록 페이지 번호와 프레임 번호를
    짝지어 저장하는 페이지 테이블을 이용한다.

    프로세스마다 각자의 페이지 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은
    메모리에 적재되어 있다. 그리고 CPU 내의 페이지 테이블 베이스 레지스터(PTBR)는
    각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.

    그런데 이렇게 페이지 테이블을 메모리에 두게되면 메모리 접근 시간이 두 배로 늘어나는
    문제가 발생한다. 이를 극복하기 위해 CPU 곁에는 TLB(Translation Lookaside Buffer)
    라는 페이지 테이블의 캐시 메모리를 둔다.
    TLB는 페이지 테이블의 캐시 이기 떄문에 페이지 테이블의 일부 내용을 참조지역성의 원리
    에 근거해 저장한다.

    CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 TLB 히트 라고 하며
    이 경우에는 페이지가 적재된 프레임을 알기 때문에 메모리에 접근을 할 필요가 없다.
    반면 TLB에 페이지 번호가 없을 경우 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해
    메모리 내의 페이지 테이블에 접근을 해야하는데 이를 페이지 미스라고 한다.

### 2. 페이징에서의 주소 변환
    하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있다.
    그렇기에 특정 주소에 접근하려면 어떤 페이지 혹은 프레임에 접근하고 싶은지,
    접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지를 알아야한다.
    그렇기에 페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호와 변위로
    이루어져있다.

    페이지 번호는 말 그대로 접근하고자 하는 페이지 번호이다.
    페이지 테이블에서 해당 페이지 번호를 찾으면 어떤 프레임에 할당되었는지를 알 수 있다.
    변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼마나 떨어져 있는지를 알려준다.
    즉 논리주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리주소<프레임번호, 변위>
    로 변환된다. 

### 3. 페이지 테이블 엔트리
    페이지 테이블의 각 행을 페이지 테이블 엔트리 라고 한다.
    페이지 테이블 엔트리에는 페이지 번호와 프레임 번호, 그 외 다른 중요한 정보도 담긴다.

    1. 유효 비트 (Valid bit)
    현재 해당 페이지에 접근 가능한지 여부를 알려준다.
    보통 하나의 프로세스의 페이지들의 일부는 스왑영역인 보조기억장치에 저장되는 경우가
    많다. 유효 비트는 현재 페이지가 어디에 적재되어 있는지를 1, 0 으로 알려준다.
    만일 유효 비트가 0인 페이지에 접근을 하게 되면 페이지 폴트라는 예외가 발생한다.
    페이지 폴트가 발생하면 CPU는 기존 작업 내역을 백업하고 원하는 페이지를 메모리로
    가져온 뒤 유효 비트를 1로 변경해 준다. 페이지 폴트를 처리했다면 이제 CPU는
    해당 페이지에 접근을할 수 있게된다.

    2. 보호 비트 (Protection bit)
    페이지에 접근할 권한을 제한하여 페이지를 보호하는 비트이다.
    0일경우 읽기만 1일경우 읽기쓰기 모두 가능한 경우가 많다.
    좀 더 복잡하게 r,w,x의 조합으로 쓰는 경우도 있는데 가령 보호비트가 100일 경우엔
    r은 1, w와 x는 0 이기에 읽기만 가능하다는것을 표현 하는것이고,
    110은 읽기쓰기, 111은 읽기, 쓰기, 실행 모두 가능하다고 표현하는것이다.

    3. 참조 비트 (Reference bit)
    CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다.
    적재 이후 CPU가 읽거나 쓴 페이지는 1로 적재 이후 한 번도 읽거나 쓴 적이 없는
    페이지는 0으로 세팅된다.

    4. 수정 비트 (Modified bit)
    해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다.
    더티 비트 (Dirty bit)라고도 부른다.
    수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지,
    할 필요가 없는지를 판단하기 위해 존재한다.
    CPU가 쓰기 작업을 수행한 페이지의 경우 보조기억장치에 저장된 페이지의 내용과
    메모리에 저장된 내용은 서로 다른 값을 갖게 된다.
    이렇게 수정된 적이 있는 페이지가 스왑 아웃될 경우 변경된 값을 보조기억장치에
    기록하는 작업이 추가되어야 한다. 이 작업이 필요한 페이지인지 아닌지를 판단하기 위해
    페지이 테이블 엔트리에 수정 비트를 두는 것이다.
